function postQuestionToDiscord() {
  // ====== Configuration ======
  const SHEET_NAME = 'Questions';
  const QUESTION_COLUMN = 1;
  const POSTED_COLUMN = 2;
  const WEBHOOK_URL = 'CHANNEL POST WEBHOOK';
  const ADMIN_ALERT_WEBHOOK = 'ADMIN WEBHOOK'; // <--- secondary alert webhook

  const SCRIPT_PROPERTY_KEY = 'lastDiscordPostDate';
  const LAST_ALERTED_KEY = 'lastQuestionsLeftAlert';
  const LOG_FILE_NAME = 'DiscordPostLog.txt';

  const tz = Session.getScriptTimeZone() || 'America/New_York';
  const now = new Date();
  const todayISO = Utilities.formatDate(now, tz, 'yyyy-MM-dd');

  // Prevent concurrent runs
  const lock = LockService.getScriptLock();
  try {
    lock.tryLock(20 * 1000);
  } catch (e) {
    Logger.log('Could not acquire lock; exiting.');
    return;
  }

  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const sheet = ss.getSheetByName(SHEET_NAME);
    if (!sheet) {
      alertToWebhook(`‚ùå Error: Sheet "${SHEET_NAME}" not found.`);
      return;
    }

    const lastRow = sheet.getLastRow();
    if (lastRow < 2) {
      alertToWebhook(`‚ö†Ô∏è The sheet "${SHEET_NAME}" has no questions under the header.`);
      maybeRefillWhenOut(sheet);
      return;
    }

    const props = PropertiesService.getScriptProperties();
    const lastPostDate = props.getProperty(SCRIPT_PROPERTY_KEY);
    if (lastPostDate === todayISO) {
      Logger.log('Already posted today; exiting.');
      return;
    }

    const maxCols = Math.max(QUESTION_COLUMN, POSTED_COLUMN);
    const range = sheet.getRange(2, 1, lastRow - 1, maxCols);
    const data = range.getValues();

    // Find first valid unposted question
    let rowIndex = -1;
    let question = '';
    for (let i = 0; i < data.length; i++) {
      const qRaw = data[i][QUESTION_COLUMN - 1];
      const q = String(qRaw == null ? '' : qRaw).trim();
      const posted = String(data[i][POSTED_COLUMN - 1] || '').trim().toLowerCase();

      if (q && posted !== 'yes') {
        rowIndex = i;
        question = q;
        break;
      }
    }

    // If no question left, refill 25 from top 100 and notify
    if (!question) {
      const appended = appendRandomFromTop100(sheet, QUESTION_COLUMN, POSTED_COLUMN);
      if (appended > 0) {
        alertToWebhook(`ü™Ñ Out of questions! Added ${appended} new randomized ones from the top 100. Stock reset to 25.`);
      } else {
        alertToWebhook(`üö® No unposted questions left and unable to refill from the top 100 in "${SHEET_NAME}".`);
      }
      return;
    }

    // Post question to main webhook
    const payload = {
      allowed_mentions: { parse: [] },
      embeds: [{
        title: 'üì¢ Daily Question!',
        description: question.length > 4096 ? question.slice(0, 4093) + '...' : question,
        color: 0xFF0000,
        footer: { text: 'Version 1.0.1' },
        timestamp: new Date().toISOString()
      }]
    };
    const resp = postToDiscordWithRetry(WEBHOOK_URL, payload);
    Logger.log(`Discord response code: ${resp.getResponseCode()}`);

    // Mark posted row
    const sheetRow = rowIndex + 2;
    sheet.getRange(sheetRow, POSTED_COLUMN).setValue('Yes');

    props.setProperty(SCRIPT_PROPERTY_KEY, todayISO);

    appendToDriveLog(LOG_FILE_NAME, [
      `Time: ${Utilities.formatDate(now, tz, 'yyyy-MM-dd HH:mm:ss')}`,
      `Row: ${sheetRow}`,
      `Question: ${question}`,
      '---'
    ].join('\n'));

    // Count remaining and check thresholds
    const remaining = countRemainingQuestions(sheet, QUESTION_COLUMN, POSTED_COLUMN);
    Logger.log(`Remaining unposted questions: ${remaining}`);

    const thresholds = [25, 10, 1];
    if (thresholds.includes(remaining)) {
      const last = props.getProperty(LAST_ALERTED_KEY);
      if (String(remaining) !== String(last)) {
        alertToWebhook(`‚ö†Ô∏è Only ${remaining} question${remaining === 1 ? '' : 's'} left in "${SHEET_NAME}".`);
        props.setProperty(LAST_ALERTED_KEY, String(remaining));
      }
    }

    // If out, refill automatically
    if (remaining === 0) {
      const appended = appendRandomFromTop100(sheet, QUESTION_COLUMN, POSTED_COLUMN);
      if (appended > 0) {
        alertToWebhook(`ü™Ñ Stock reached 0 after posting. Added ${appended} new randomized ones from the top 100!`);
      }
    }

  } catch (e) {
    alertToWebhook(`‚ùå Error posting to Discord: ${e && e.stack ? e.stack : e}`);
  } finally {
    lock.releaseLock();
  }

  // ===== Helpers =====
  function alertToWebhook(message) {
    try {
      const payload = {
        content: message,
        allowed_mentions: { parse: [] }
      };
      UrlFetchApp.fetch(ADMIN_ALERT_WEBHOOK, {
        method: 'post',
        contentType: 'application/json',
        payload: JSON.stringify(payload),
        muteHttpExceptions: true
      });
      Logger.log('Alert sent to secondary webhook.');
    } catch (err) {
      Logger.log('Failed to send alert webhook: ' + err);
    }
  }

  function countRemainingQuestions(sheet, qCol, postedCol) {
    const lr = sheet.getLastRow();
    if (lr < 2) return 0;
    const vals = sheet.getRange(2, 1, lr - 1, Math.max(qCol, postedCol)).getValues();
    let cnt = 0;
    vals.forEach(r => {
      const q = String(r[qCol - 1] || '').trim();
      const p = String(r[postedCol - 1] || '').trim().toLowerCase();
      if (q && p !== 'yes') cnt++;
    });
    return cnt;
  }

  function appendRandomFromTop100(sheet, qCol, postedCol) {
    const lr = sheet.getLastRow();
    if (lr < 2) return 0;
    const topCount = Math.min(100, lr - 1);
    const bank = sheet.getRange(2, qCol, topCount, 1).getValues()
      .map(r => String(r[0] || '').trim())
      .filter(Boolean);
    if (!bank.length) return 0;
    shuffleInPlace(bank);
    const add = bank.slice(0, Math.min(25, bank.length));
    const cols = Math.max(qCol, postedCol);
    const rows = add.map(q => {
      const arr = new Array(cols).fill('');
      arr[qCol - 1] = q;
      return arr;
    });
    sheet.getRange(lr + 1, 1, rows.length, cols).setValues(rows);
    Logger.log(`Appended ${rows.length} questions.`);
    return rows.length;
  }

  function shuffleInPlace(a) {
    for (let i = a.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [a[i], a[j]] = [a[j], a[i]];
    }
  }

  function postToDiscordWithRetry(url, json, max = 4) {
    const opts = {
      method: 'post',
      contentType: 'application/json',
      payload: JSON.stringify(json),
      muteHttpExceptions: true
    };
    let wait = 500;
    for (let i = 0; i < max; i++) {
      const res = UrlFetchApp.fetch(url, opts);
      const code = res.getResponseCode();
      if (code >= 200 && code < 300) return res;
      if (code === 429 || (code >= 500 && code < 600)) {
        Utilities.sleep(wait);
        wait *= 2;
        continue;
      }
      throw new Error(`Discord webhook failed: ${code}`);
    }
    throw new Error('Discord webhook failed after retries.');
  }

  function appendToDriveLog(name, text) {
    let file;
    const it = DriveApp.getFilesByName(name);
    if (it.hasNext()) {
      file = it.next();
      file.setContent(file.getBlob().getDataAsString() + '\n' + text);
    } else {
      file = DriveApp.createFile(name, text, MimeType.PLAIN_TEXT);
    }
    Logger.log('Wrote log -> ' + file.getUrl());
  }
}
